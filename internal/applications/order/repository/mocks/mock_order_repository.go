// Code generated by mockery; DO NOT EDIT.
// github.com/vektra/mockery
// template: testify

package repository

import (
	"context"
	"ichi-go/internal/applications/order/model"
	"ichi-go/pkg/db/query"
	"time"

	mock "github.com/stretchr/testify/mock"
)

// NewMockOrderRepository creates a new instance of MockOrderRepository. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockOrderRepository(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockOrderRepository {
	mock := &MockOrderRepository{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// MockOrderRepository is an autogenerated mock type for the OrderRepository type
type MockOrderRepository struct {
	mock.Mock
}

type MockOrderRepository_Expecter struct {
	mock *mock.Mock
}

func (_m *MockOrderRepository) EXPECT() *MockOrderRepository_Expecter {
	return &MockOrderRepository_Expecter{mock: &_m.Mock}
}

// AddItem provides a mock function for the type MockOrderRepository
func (_mock *MockOrderRepository) AddItem(ctx context.Context, item *model.OrderItem) (*model.OrderItem, error) {
	ret := _mock.Called(ctx, item)

	if len(ret) == 0 {
		panic("no return value specified for AddItem")
	}

	var r0 *model.OrderItem
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *model.OrderItem) (*model.OrderItem, error)); ok {
		return returnFunc(ctx, item)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, *model.OrderItem) *model.OrderItem); ok {
		r0 = returnFunc(ctx, item)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*model.OrderItem)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, *model.OrderItem) error); ok {
		r1 = returnFunc(ctx, item)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockOrderRepository_AddItem_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AddItem'
type MockOrderRepository_AddItem_Call struct {
	*mock.Call
}

// AddItem is a helper method to define mock.On call
//   - ctx context.Context
//   - item *model.OrderItem
func (_e *MockOrderRepository_Expecter) AddItem(ctx interface{}, item interface{}) *MockOrderRepository_AddItem_Call {
	return &MockOrderRepository_AddItem_Call{Call: _e.mock.On("AddItem", ctx, item)}
}

func (_c *MockOrderRepository_AddItem_Call) Run(run func(ctx context.Context, item *model.OrderItem)) *MockOrderRepository_AddItem_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *model.OrderItem
		if args[1] != nil {
			arg1 = args[1].(*model.OrderItem)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockOrderRepository_AddItem_Call) Return(orderItem *model.OrderItem, err error) *MockOrderRepository_AddItem_Call {
	_c.Call.Return(orderItem, err)
	return _c
}

func (_c *MockOrderRepository_AddItem_Call) RunAndReturn(run func(ctx context.Context, item *model.OrderItem) (*model.OrderItem, error)) *MockOrderRepository_AddItem_Call {
	_c.Call.Return(run)
	return _c
}

// CancelOrder provides a mock function for the type MockOrderRepository
func (_mock *MockOrderRepository) CancelOrder(ctx context.Context, orderID string, reason string) error {
	ret := _mock.Called(ctx, orderID, reason)

	if len(ret) == 0 {
		panic("no return value specified for CancelOrder")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string, string) error); ok {
		r0 = returnFunc(ctx, orderID, reason)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockOrderRepository_CancelOrder_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CancelOrder'
type MockOrderRepository_CancelOrder_Call struct {
	*mock.Call
}

// CancelOrder is a helper method to define mock.On call
//   - ctx context.Context
//   - orderID string
//   - reason string
func (_e *MockOrderRepository_Expecter) CancelOrder(ctx interface{}, orderID interface{}, reason interface{}) *MockOrderRepository_CancelOrder_Call {
	return &MockOrderRepository_CancelOrder_Call{Call: _e.mock.On("CancelOrder", ctx, orderID, reason)}
}

func (_c *MockOrderRepository_CancelOrder_Call) Run(run func(ctx context.Context, orderID string, reason string)) *MockOrderRepository_CancelOrder_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		var arg2 string
		if args[2] != nil {
			arg2 = args[2].(string)
		}
		run(
			arg0,
			arg1,
			arg2,
		)
	})
	return _c
}

func (_c *MockOrderRepository_CancelOrder_Call) Return(err error) *MockOrderRepository_CancelOrder_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockOrderRepository_CancelOrder_Call) RunAndReturn(run func(ctx context.Context, orderID string, reason string) error) *MockOrderRepository_CancelOrder_Call {
	_c.Call.Return(run)
	return _c
}

// CountByStatus provides a mock function for the type MockOrderRepository
func (_mock *MockOrderRepository) CountByStatus(ctx context.Context, status string) (int, error) {
	ret := _mock.Called(ctx, status)

	if len(ret) == 0 {
		panic("no return value specified for CountByStatus")
	}

	var r0 int
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string) (int, error)); ok {
		return returnFunc(ctx, status)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, string) int); ok {
		r0 = returnFunc(ctx, status)
	} else {
		r0 = ret.Get(0).(int)
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = returnFunc(ctx, status)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockOrderRepository_CountByStatus_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CountByStatus'
type MockOrderRepository_CountByStatus_Call struct {
	*mock.Call
}

// CountByStatus is a helper method to define mock.On call
//   - ctx context.Context
//   - status string
func (_e *MockOrderRepository_Expecter) CountByStatus(ctx interface{}, status interface{}) *MockOrderRepository_CountByStatus_Call {
	return &MockOrderRepository_CountByStatus_Call{Call: _e.mock.On("CountByStatus", ctx, status)}
}

func (_c *MockOrderRepository_CountByStatus_Call) Run(run func(ctx context.Context, status string)) *MockOrderRepository_CountByStatus_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockOrderRepository_CountByStatus_Call) Return(n int, err error) *MockOrderRepository_CountByStatus_Call {
	_c.Call.Return(n, err)
	return _c
}

func (_c *MockOrderRepository_CountByStatus_Call) RunAndReturn(run func(ctx context.Context, status string) (int, error)) *MockOrderRepository_CountByStatus_Call {
	_c.Call.Return(run)
	return _c
}

// Create provides a mock function for the type MockOrderRepository
func (_mock *MockOrderRepository) Create(ctx context.Context, order *model.Order) (*model.Order, error) {
	ret := _mock.Called(ctx, order)

	if len(ret) == 0 {
		panic("no return value specified for Create")
	}

	var r0 *model.Order
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *model.Order) (*model.Order, error)); ok {
		return returnFunc(ctx, order)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, *model.Order) *model.Order); ok {
		r0 = returnFunc(ctx, order)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*model.Order)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, *model.Order) error); ok {
		r1 = returnFunc(ctx, order)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockOrderRepository_Create_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Create'
type MockOrderRepository_Create_Call struct {
	*mock.Call
}

// Create is a helper method to define mock.On call
//   - ctx context.Context
//   - order *model.Order
func (_e *MockOrderRepository_Expecter) Create(ctx interface{}, order interface{}) *MockOrderRepository_Create_Call {
	return &MockOrderRepository_Create_Call{Call: _e.mock.On("Create", ctx, order)}
}

func (_c *MockOrderRepository_Create_Call) Run(run func(ctx context.Context, order *model.Order)) *MockOrderRepository_Create_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *model.Order
		if args[1] != nil {
			arg1 = args[1].(*model.Order)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockOrderRepository_Create_Call) Return(order1 *model.Order, err error) *MockOrderRepository_Create_Call {
	_c.Call.Return(order1, err)
	return _c
}

func (_c *MockOrderRepository_Create_Call) RunAndReturn(run func(ctx context.Context, order *model.Order) (*model.Order, error)) *MockOrderRepository_Create_Call {
	_c.Call.Return(run)
	return _c
}

// Delete provides a mock function for the type MockOrderRepository
func (_mock *MockOrderRepository) Delete(ctx context.Context, id string) error {
	ret := _mock.Called(ctx, id)

	if len(ret) == 0 {
		panic("no return value specified for Delete")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string) error); ok {
		r0 = returnFunc(ctx, id)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockOrderRepository_Delete_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Delete'
type MockOrderRepository_Delete_Call struct {
	*mock.Call
}

// Delete is a helper method to define mock.On call
//   - ctx context.Context
//   - id string
func (_e *MockOrderRepository_Expecter) Delete(ctx interface{}, id interface{}) *MockOrderRepository_Delete_Call {
	return &MockOrderRepository_Delete_Call{Call: _e.mock.On("Delete", ctx, id)}
}

func (_c *MockOrderRepository_Delete_Call) Run(run func(ctx context.Context, id string)) *MockOrderRepository_Delete_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockOrderRepository_Delete_Call) Return(err error) *MockOrderRepository_Delete_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockOrderRepository_Delete_Call) RunAndReturn(run func(ctx context.Context, id string) error) *MockOrderRepository_Delete_Call {
	_c.Call.Return(run)
	return _c
}

// FindByDateRange provides a mock function for the type MockOrderRepository
func (_mock *MockOrderRepository) FindByDateRange(ctx context.Context, startDate time.Time, endDate time.Time, scopes ...query.QueryScope) ([]*model.Order, error) {
	var tmpRet mock.Arguments
	if len(scopes) > 0 {
		tmpRet = _mock.Called(ctx, startDate, endDate, scopes)
	} else {
		tmpRet = _mock.Called(ctx, startDate, endDate)
	}
	ret := tmpRet

	if len(ret) == 0 {
		panic("no return value specified for FindByDateRange")
	}

	var r0 []*model.Order
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, time.Time, time.Time, ...query.QueryScope) ([]*model.Order, error)); ok {
		return returnFunc(ctx, startDate, endDate, scopes...)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, time.Time, time.Time, ...query.QueryScope) []*model.Order); ok {
		r0 = returnFunc(ctx, startDate, endDate, scopes...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*model.Order)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, time.Time, time.Time, ...query.QueryScope) error); ok {
		r1 = returnFunc(ctx, startDate, endDate, scopes...)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockOrderRepository_FindByDateRange_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'FindByDateRange'
type MockOrderRepository_FindByDateRange_Call struct {
	*mock.Call
}

// FindByDateRange is a helper method to define mock.On call
//   - ctx context.Context
//   - startDate time.Time
//   - endDate time.Time
//   - scopes ...query.QueryScope
func (_e *MockOrderRepository_Expecter) FindByDateRange(ctx interface{}, startDate interface{}, endDate interface{}, scopes ...interface{}) *MockOrderRepository_FindByDateRange_Call {
	return &MockOrderRepository_FindByDateRange_Call{Call: _e.mock.On("FindByDateRange",
		append([]interface{}{ctx, startDate, endDate}, scopes...)...)}
}

func (_c *MockOrderRepository_FindByDateRange_Call) Run(run func(ctx context.Context, startDate time.Time, endDate time.Time, scopes ...query.QueryScope)) *MockOrderRepository_FindByDateRange_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 time.Time
		if args[1] != nil {
			arg1 = args[1].(time.Time)
		}
		var arg2 time.Time
		if args[2] != nil {
			arg2 = args[2].(time.Time)
		}
		var arg3 []query.QueryScope
		var variadicArgs []query.QueryScope
		if len(args) > 3 {
			variadicArgs = args[3].([]query.QueryScope)
		}
		arg3 = variadicArgs
		run(
			arg0,
			arg1,
			arg2,
			arg3...,
		)
	})
	return _c
}

func (_c *MockOrderRepository_FindByDateRange_Call) Return(orders []*model.Order, err error) *MockOrderRepository_FindByDateRange_Call {
	_c.Call.Return(orders, err)
	return _c
}

func (_c *MockOrderRepository_FindByDateRange_Call) RunAndReturn(run func(ctx context.Context, startDate time.Time, endDate time.Time, scopes ...query.QueryScope) ([]*model.Order, error)) *MockOrderRepository_FindByDateRange_Call {
	_c.Call.Return(run)
	return _c
}

// FindByStatus provides a mock function for the type MockOrderRepository
func (_mock *MockOrderRepository) FindByStatus(ctx context.Context, status string, scopes ...query.QueryScope) ([]*model.Order, error) {
	var tmpRet mock.Arguments
	if len(scopes) > 0 {
		tmpRet = _mock.Called(ctx, status, scopes)
	} else {
		tmpRet = _mock.Called(ctx, status)
	}
	ret := tmpRet

	if len(ret) == 0 {
		panic("no return value specified for FindByStatus")
	}

	var r0 []*model.Order
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string, ...query.QueryScope) ([]*model.Order, error)); ok {
		return returnFunc(ctx, status, scopes...)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, string, ...query.QueryScope) []*model.Order); ok {
		r0 = returnFunc(ctx, status, scopes...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*model.Order)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, string, ...query.QueryScope) error); ok {
		r1 = returnFunc(ctx, status, scopes...)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockOrderRepository_FindByStatus_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'FindByStatus'
type MockOrderRepository_FindByStatus_Call struct {
	*mock.Call
}

// FindByStatus is a helper method to define mock.On call
//   - ctx context.Context
//   - status string
//   - scopes ...query.QueryScope
func (_e *MockOrderRepository_Expecter) FindByStatus(ctx interface{}, status interface{}, scopes ...interface{}) *MockOrderRepository_FindByStatus_Call {
	return &MockOrderRepository_FindByStatus_Call{Call: _e.mock.On("FindByStatus",
		append([]interface{}{ctx, status}, scopes...)...)}
}

func (_c *MockOrderRepository_FindByStatus_Call) Run(run func(ctx context.Context, status string, scopes ...query.QueryScope)) *MockOrderRepository_FindByStatus_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		var arg2 []query.QueryScope
		var variadicArgs []query.QueryScope
		if len(args) > 2 {
			variadicArgs = args[2].([]query.QueryScope)
		}
		arg2 = variadicArgs
		run(
			arg0,
			arg1,
			arg2...,
		)
	})
	return _c
}

func (_c *MockOrderRepository_FindByStatus_Call) Return(orders []*model.Order, err error) *MockOrderRepository_FindByStatus_Call {
	_c.Call.Return(orders, err)
	return _c
}

func (_c *MockOrderRepository_FindByStatus_Call) RunAndReturn(run func(ctx context.Context, status string, scopes ...query.QueryScope) ([]*model.Order, error)) *MockOrderRepository_FindByStatus_Call {
	_c.Call.Return(run)
	return _c
}

// FindByUserID provides a mock function for the type MockOrderRepository
func (_mock *MockOrderRepository) FindByUserID(ctx context.Context, userID int64, scopes ...query.QueryScope) ([]*model.Order, error) {
	var tmpRet mock.Arguments
	if len(scopes) > 0 {
		tmpRet = _mock.Called(ctx, userID, scopes)
	} else {
		tmpRet = _mock.Called(ctx, userID)
	}
	ret := tmpRet

	if len(ret) == 0 {
		panic("no return value specified for FindByUserID")
	}

	var r0 []*model.Order
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, int64, ...query.QueryScope) ([]*model.Order, error)); ok {
		return returnFunc(ctx, userID, scopes...)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, int64, ...query.QueryScope) []*model.Order); ok {
		r0 = returnFunc(ctx, userID, scopes...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*model.Order)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, int64, ...query.QueryScope) error); ok {
		r1 = returnFunc(ctx, userID, scopes...)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockOrderRepository_FindByUserID_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'FindByUserID'
type MockOrderRepository_FindByUserID_Call struct {
	*mock.Call
}

// FindByUserID is a helper method to define mock.On call
//   - ctx context.Context
//   - userID int64
//   - scopes ...query.QueryScope
func (_e *MockOrderRepository_Expecter) FindByUserID(ctx interface{}, userID interface{}, scopes ...interface{}) *MockOrderRepository_FindByUserID_Call {
	return &MockOrderRepository_FindByUserID_Call{Call: _e.mock.On("FindByUserID",
		append([]interface{}{ctx, userID}, scopes...)...)}
}

func (_c *MockOrderRepository_FindByUserID_Call) Run(run func(ctx context.Context, userID int64, scopes ...query.QueryScope)) *MockOrderRepository_FindByUserID_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 int64
		if args[1] != nil {
			arg1 = args[1].(int64)
		}
		var arg2 []query.QueryScope
		var variadicArgs []query.QueryScope
		if len(args) > 2 {
			variadicArgs = args[2].([]query.QueryScope)
		}
		arg2 = variadicArgs
		run(
			arg0,
			arg1,
			arg2...,
		)
	})
	return _c
}

func (_c *MockOrderRepository_FindByUserID_Call) Return(orders []*model.Order, err error) *MockOrderRepository_FindByUserID_Call {
	_c.Call.Return(orders, err)
	return _c
}

func (_c *MockOrderRepository_FindByUserID_Call) RunAndReturn(run func(ctx context.Context, userID int64, scopes ...query.QueryScope) ([]*model.Order, error)) *MockOrderRepository_FindByUserID_Call {
	_c.Call.Return(run)
	return _c
}

// FindPendingPayment provides a mock function for the type MockOrderRepository
func (_mock *MockOrderRepository) FindPendingPayment(ctx context.Context, olderThan time.Duration) ([]*model.Order, error) {
	ret := _mock.Called(ctx, olderThan)

	if len(ret) == 0 {
		panic("no return value specified for FindPendingPayment")
	}

	var r0 []*model.Order
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, time.Duration) ([]*model.Order, error)); ok {
		return returnFunc(ctx, olderThan)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, time.Duration) []*model.Order); ok {
		r0 = returnFunc(ctx, olderThan)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*model.Order)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, time.Duration) error); ok {
		r1 = returnFunc(ctx, olderThan)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockOrderRepository_FindPendingPayment_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'FindPendingPayment'
type MockOrderRepository_FindPendingPayment_Call struct {
	*mock.Call
}

// FindPendingPayment is a helper method to define mock.On call
//   - ctx context.Context
//   - olderThan time.Duration
func (_e *MockOrderRepository_Expecter) FindPendingPayment(ctx interface{}, olderThan interface{}) *MockOrderRepository_FindPendingPayment_Call {
	return &MockOrderRepository_FindPendingPayment_Call{Call: _e.mock.On("FindPendingPayment", ctx, olderThan)}
}

func (_c *MockOrderRepository_FindPendingPayment_Call) Run(run func(ctx context.Context, olderThan time.Duration)) *MockOrderRepository_FindPendingPayment_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 time.Duration
		if args[1] != nil {
			arg1 = args[1].(time.Duration)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockOrderRepository_FindPendingPayment_Call) Return(orders []*model.Order, err error) *MockOrderRepository_FindPendingPayment_Call {
	_c.Call.Return(orders, err)
	return _c
}

func (_c *MockOrderRepository_FindPendingPayment_Call) RunAndReturn(run func(ctx context.Context, olderThan time.Duration) ([]*model.Order, error)) *MockOrderRepository_FindPendingPayment_Call {
	_c.Call.Return(run)
	return _c
}

// FindRefundable provides a mock function for the type MockOrderRepository
func (_mock *MockOrderRepository) FindRefundable(ctx context.Context) ([]*model.Order, error) {
	ret := _mock.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for FindRefundable")
	}

	var r0 []*model.Order
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context) ([]*model.Order, error)); ok {
		return returnFunc(ctx)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context) []*model.Order); ok {
		r0 = returnFunc(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*model.Order)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = returnFunc(ctx)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockOrderRepository_FindRefundable_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'FindRefundable'
type MockOrderRepository_FindRefundable_Call struct {
	*mock.Call
}

// FindRefundable is a helper method to define mock.On call
//   - ctx context.Context
func (_e *MockOrderRepository_Expecter) FindRefundable(ctx interface{}) *MockOrderRepository_FindRefundable_Call {
	return &MockOrderRepository_FindRefundable_Call{Call: _e.mock.On("FindRefundable", ctx)}
}

func (_c *MockOrderRepository_FindRefundable_Call) Run(run func(ctx context.Context)) *MockOrderRepository_FindRefundable_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *MockOrderRepository_FindRefundable_Call) Return(orders []*model.Order, err error) *MockOrderRepository_FindRefundable_Call {
	_c.Call.Return(orders, err)
	return _c
}

func (_c *MockOrderRepository_FindRefundable_Call) RunAndReturn(run func(ctx context.Context) ([]*model.Order, error)) *MockOrderRepository_FindRefundable_Call {
	_c.Call.Return(run)
	return _c
}

// GetByID provides a mock function for the type MockOrderRepository
func (_mock *MockOrderRepository) GetByID(ctx context.Context, id string) (*model.Order, error) {
	ret := _mock.Called(ctx, id)

	if len(ret) == 0 {
		panic("no return value specified for GetByID")
	}

	var r0 *model.Order
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string) (*model.Order, error)); ok {
		return returnFunc(ctx, id)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, string) *model.Order); ok {
		r0 = returnFunc(ctx, id)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*model.Order)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = returnFunc(ctx, id)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockOrderRepository_GetByID_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetByID'
type MockOrderRepository_GetByID_Call struct {
	*mock.Call
}

// GetByID is a helper method to define mock.On call
//   - ctx context.Context
//   - id string
func (_e *MockOrderRepository_Expecter) GetByID(ctx interface{}, id interface{}) *MockOrderRepository_GetByID_Call {
	return &MockOrderRepository_GetByID_Call{Call: _e.mock.On("GetByID", ctx, id)}
}

func (_c *MockOrderRepository_GetByID_Call) Run(run func(ctx context.Context, id string)) *MockOrderRepository_GetByID_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockOrderRepository_GetByID_Call) Return(order *model.Order, err error) *MockOrderRepository_GetByID_Call {
	_c.Call.Return(order, err)
	return _c
}

func (_c *MockOrderRepository_GetByID_Call) RunAndReturn(run func(ctx context.Context, id string) (*model.Order, error)) *MockOrderRepository_GetByID_Call {
	_c.Call.Return(run)
	return _c
}

// GetByOrderNumber provides a mock function for the type MockOrderRepository
func (_mock *MockOrderRepository) GetByOrderNumber(ctx context.Context, orderNumber string) (*model.Order, error) {
	ret := _mock.Called(ctx, orderNumber)

	if len(ret) == 0 {
		panic("no return value specified for GetByOrderNumber")
	}

	var r0 *model.Order
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string) (*model.Order, error)); ok {
		return returnFunc(ctx, orderNumber)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, string) *model.Order); ok {
		r0 = returnFunc(ctx, orderNumber)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*model.Order)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = returnFunc(ctx, orderNumber)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockOrderRepository_GetByOrderNumber_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetByOrderNumber'
type MockOrderRepository_GetByOrderNumber_Call struct {
	*mock.Call
}

// GetByOrderNumber is a helper method to define mock.On call
//   - ctx context.Context
//   - orderNumber string
func (_e *MockOrderRepository_Expecter) GetByOrderNumber(ctx interface{}, orderNumber interface{}) *MockOrderRepository_GetByOrderNumber_Call {
	return &MockOrderRepository_GetByOrderNumber_Call{Call: _e.mock.On("GetByOrderNumber", ctx, orderNumber)}
}

func (_c *MockOrderRepository_GetByOrderNumber_Call) Run(run func(ctx context.Context, orderNumber string)) *MockOrderRepository_GetByOrderNumber_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockOrderRepository_GetByOrderNumber_Call) Return(order *model.Order, err error) *MockOrderRepository_GetByOrderNumber_Call {
	_c.Call.Return(order, err)
	return _c
}

func (_c *MockOrderRepository_GetByOrderNumber_Call) RunAndReturn(run func(ctx context.Context, orderNumber string) (*model.Order, error)) *MockOrderRepository_GetByOrderNumber_Call {
	_c.Call.Return(run)
	return _c
}

// GetItemsByOrderID provides a mock function for the type MockOrderRepository
func (_mock *MockOrderRepository) GetItemsByOrderID(ctx context.Context, orderID int64) ([]*model.OrderItem, error) {
	ret := _mock.Called(ctx, orderID)

	if len(ret) == 0 {
		panic("no return value specified for GetItemsByOrderID")
	}

	var r0 []*model.OrderItem
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, int64) ([]*model.OrderItem, error)); ok {
		return returnFunc(ctx, orderID)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, int64) []*model.OrderItem); ok {
		r0 = returnFunc(ctx, orderID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*model.OrderItem)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, int64) error); ok {
		r1 = returnFunc(ctx, orderID)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockOrderRepository_GetItemsByOrderID_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetItemsByOrderID'
type MockOrderRepository_GetItemsByOrderID_Call struct {
	*mock.Call
}

// GetItemsByOrderID is a helper method to define mock.On call
//   - ctx context.Context
//   - orderID int64
func (_e *MockOrderRepository_Expecter) GetItemsByOrderID(ctx interface{}, orderID interface{}) *MockOrderRepository_GetItemsByOrderID_Call {
	return &MockOrderRepository_GetItemsByOrderID_Call{Call: _e.mock.On("GetItemsByOrderID", ctx, orderID)}
}

func (_c *MockOrderRepository_GetItemsByOrderID_Call) Run(run func(ctx context.Context, orderID int64)) *MockOrderRepository_GetItemsByOrderID_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 int64
		if args[1] != nil {
			arg1 = args[1].(int64)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockOrderRepository_GetItemsByOrderID_Call) Return(orderItems []*model.OrderItem, err error) *MockOrderRepository_GetItemsByOrderID_Call {
	_c.Call.Return(orderItems, err)
	return _c
}

func (_c *MockOrderRepository_GetItemsByOrderID_Call) RunAndReturn(run func(ctx context.Context, orderID int64) ([]*model.OrderItem, error)) *MockOrderRepository_GetItemsByOrderID_Call {
	_c.Call.Return(run)
	return _c
}

// GetOrderWithItems provides a mock function for the type MockOrderRepository
func (_mock *MockOrderRepository) GetOrderWithItems(ctx context.Context, orderID string) (*model.Order, error) {
	ret := _mock.Called(ctx, orderID)

	if len(ret) == 0 {
		panic("no return value specified for GetOrderWithItems")
	}

	var r0 *model.Order
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string) (*model.Order, error)); ok {
		return returnFunc(ctx, orderID)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, string) *model.Order); ok {
		r0 = returnFunc(ctx, orderID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*model.Order)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = returnFunc(ctx, orderID)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockOrderRepository_GetOrderWithItems_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetOrderWithItems'
type MockOrderRepository_GetOrderWithItems_Call struct {
	*mock.Call
}

// GetOrderWithItems is a helper method to define mock.On call
//   - ctx context.Context
//   - orderID string
func (_e *MockOrderRepository_Expecter) GetOrderWithItems(ctx interface{}, orderID interface{}) *MockOrderRepository_GetOrderWithItems_Call {
	return &MockOrderRepository_GetOrderWithItems_Call{Call: _e.mock.On("GetOrderWithItems", ctx, orderID)}
}

func (_c *MockOrderRepository_GetOrderWithItems_Call) Run(run func(ctx context.Context, orderID string)) *MockOrderRepository_GetOrderWithItems_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockOrderRepository_GetOrderWithItems_Call) Return(order *model.Order, err error) *MockOrderRepository_GetOrderWithItems_Call {
	_c.Call.Return(order, err)
	return _c
}

func (_c *MockOrderRepository_GetOrderWithItems_Call) RunAndReturn(run func(ctx context.Context, orderID string) (*model.Order, error)) *MockOrderRepository_GetOrderWithItems_Call {
	_c.Call.Return(run)
	return _c
}

// List provides a mock function for the type MockOrderRepository
func (_mock *MockOrderRepository) List(ctx context.Context, scopes ...query.QueryScope) ([]*model.Order, error) {
	var tmpRet mock.Arguments
	if len(scopes) > 0 {
		tmpRet = _mock.Called(ctx, scopes)
	} else {
		tmpRet = _mock.Called(ctx)
	}
	ret := tmpRet

	if len(ret) == 0 {
		panic("no return value specified for List")
	}

	var r0 []*model.Order
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, ...query.QueryScope) ([]*model.Order, error)); ok {
		return returnFunc(ctx, scopes...)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, ...query.QueryScope) []*model.Order); ok {
		r0 = returnFunc(ctx, scopes...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*model.Order)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, ...query.QueryScope) error); ok {
		r1 = returnFunc(ctx, scopes...)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockOrderRepository_List_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'List'
type MockOrderRepository_List_Call struct {
	*mock.Call
}

// List is a helper method to define mock.On call
//   - ctx context.Context
//   - scopes ...query.QueryScope
func (_e *MockOrderRepository_Expecter) List(ctx interface{}, scopes ...interface{}) *MockOrderRepository_List_Call {
	return &MockOrderRepository_List_Call{Call: _e.mock.On("List",
		append([]interface{}{ctx}, scopes...)...)}
}

func (_c *MockOrderRepository_List_Call) Run(run func(ctx context.Context, scopes ...query.QueryScope)) *MockOrderRepository_List_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 []query.QueryScope
		var variadicArgs []query.QueryScope
		if len(args) > 1 {
			variadicArgs = args[1].([]query.QueryScope)
		}
		arg1 = variadicArgs
		run(
			arg0,
			arg1...,
		)
	})
	return _c
}

func (_c *MockOrderRepository_List_Call) Return(orders []*model.Order, err error) *MockOrderRepository_List_Call {
	_c.Call.Return(orders, err)
	return _c
}

func (_c *MockOrderRepository_List_Call) RunAndReturn(run func(ctx context.Context, scopes ...query.QueryScope) ([]*model.Order, error)) *MockOrderRepository_List_Call {
	_c.Call.Return(run)
	return _c
}

// MarkAsDelivered provides a mock function for the type MockOrderRepository
func (_mock *MockOrderRepository) MarkAsDelivered(ctx context.Context, orderID string) error {
	ret := _mock.Called(ctx, orderID)

	if len(ret) == 0 {
		panic("no return value specified for MarkAsDelivered")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string) error); ok {
		r0 = returnFunc(ctx, orderID)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockOrderRepository_MarkAsDelivered_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'MarkAsDelivered'
type MockOrderRepository_MarkAsDelivered_Call struct {
	*mock.Call
}

// MarkAsDelivered is a helper method to define mock.On call
//   - ctx context.Context
//   - orderID string
func (_e *MockOrderRepository_Expecter) MarkAsDelivered(ctx interface{}, orderID interface{}) *MockOrderRepository_MarkAsDelivered_Call {
	return &MockOrderRepository_MarkAsDelivered_Call{Call: _e.mock.On("MarkAsDelivered", ctx, orderID)}
}

func (_c *MockOrderRepository_MarkAsDelivered_Call) Run(run func(ctx context.Context, orderID string)) *MockOrderRepository_MarkAsDelivered_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockOrderRepository_MarkAsDelivered_Call) Return(err error) *MockOrderRepository_MarkAsDelivered_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockOrderRepository_MarkAsDelivered_Call) RunAndReturn(run func(ctx context.Context, orderID string) error) *MockOrderRepository_MarkAsDelivered_Call {
	_c.Call.Return(run)
	return _c
}

// MarkAsPaid provides a mock function for the type MockOrderRepository
func (_mock *MockOrderRepository) MarkAsPaid(ctx context.Context, orderID string, transactionID string) error {
	ret := _mock.Called(ctx, orderID, transactionID)

	if len(ret) == 0 {
		panic("no return value specified for MarkAsPaid")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string, string) error); ok {
		r0 = returnFunc(ctx, orderID, transactionID)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockOrderRepository_MarkAsPaid_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'MarkAsPaid'
type MockOrderRepository_MarkAsPaid_Call struct {
	*mock.Call
}

// MarkAsPaid is a helper method to define mock.On call
//   - ctx context.Context
//   - orderID string
//   - transactionID string
func (_e *MockOrderRepository_Expecter) MarkAsPaid(ctx interface{}, orderID interface{}, transactionID interface{}) *MockOrderRepository_MarkAsPaid_Call {
	return &MockOrderRepository_MarkAsPaid_Call{Call: _e.mock.On("MarkAsPaid", ctx, orderID, transactionID)}
}

func (_c *MockOrderRepository_MarkAsPaid_Call) Run(run func(ctx context.Context, orderID string, transactionID string)) *MockOrderRepository_MarkAsPaid_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		var arg2 string
		if args[2] != nil {
			arg2 = args[2].(string)
		}
		run(
			arg0,
			arg1,
			arg2,
		)
	})
	return _c
}

func (_c *MockOrderRepository_MarkAsPaid_Call) Return(err error) *MockOrderRepository_MarkAsPaid_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockOrderRepository_MarkAsPaid_Call) RunAndReturn(run func(ctx context.Context, orderID string, transactionID string) error) *MockOrderRepository_MarkAsPaid_Call {
	_c.Call.Return(run)
	return _c
}

// MarkAsShipped provides a mock function for the type MockOrderRepository
func (_mock *MockOrderRepository) MarkAsShipped(ctx context.Context, orderID string, trackingNumber string) error {
	ret := _mock.Called(ctx, orderID, trackingNumber)

	if len(ret) == 0 {
		panic("no return value specified for MarkAsShipped")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string, string) error); ok {
		r0 = returnFunc(ctx, orderID, trackingNumber)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockOrderRepository_MarkAsShipped_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'MarkAsShipped'
type MockOrderRepository_MarkAsShipped_Call struct {
	*mock.Call
}

// MarkAsShipped is a helper method to define mock.On call
//   - ctx context.Context
//   - orderID string
//   - trackingNumber string
func (_e *MockOrderRepository_Expecter) MarkAsShipped(ctx interface{}, orderID interface{}, trackingNumber interface{}) *MockOrderRepository_MarkAsShipped_Call {
	return &MockOrderRepository_MarkAsShipped_Call{Call: _e.mock.On("MarkAsShipped", ctx, orderID, trackingNumber)}
}

func (_c *MockOrderRepository_MarkAsShipped_Call) Run(run func(ctx context.Context, orderID string, trackingNumber string)) *MockOrderRepository_MarkAsShipped_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		var arg2 string
		if args[2] != nil {
			arg2 = args[2].(string)
		}
		run(
			arg0,
			arg1,
			arg2,
		)
	})
	return _c
}

func (_c *MockOrderRepository_MarkAsShipped_Call) Return(err error) *MockOrderRepository_MarkAsShipped_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockOrderRepository_MarkAsShipped_Call) RunAndReturn(run func(ctx context.Context, orderID string, trackingNumber string) error) *MockOrderRepository_MarkAsShipped_Call {
	_c.Call.Return(run)
	return _c
}

// Paginate provides a mock function for the type MockOrderRepository
func (_mock *MockOrderRepository) Paginate(ctx context.Context, page int, perPage int, scopes ...query.QueryScope) ([]*model.Order, int, error) {
	var tmpRet mock.Arguments
	if len(scopes) > 0 {
		tmpRet = _mock.Called(ctx, page, perPage, scopes)
	} else {
		tmpRet = _mock.Called(ctx, page, perPage)
	}
	ret := tmpRet

	if len(ret) == 0 {
		panic("no return value specified for Paginate")
	}

	var r0 []*model.Order
	var r1 int
	var r2 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, int, int, ...query.QueryScope) ([]*model.Order, int, error)); ok {
		return returnFunc(ctx, page, perPage, scopes...)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, int, int, ...query.QueryScope) []*model.Order); ok {
		r0 = returnFunc(ctx, page, perPage, scopes...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*model.Order)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, int, int, ...query.QueryScope) int); ok {
		r1 = returnFunc(ctx, page, perPage, scopes...)
	} else {
		r1 = ret.Get(1).(int)
	}
	if returnFunc, ok := ret.Get(2).(func(context.Context, int, int, ...query.QueryScope) error); ok {
		r2 = returnFunc(ctx, page, perPage, scopes...)
	} else {
		r2 = ret.Error(2)
	}
	return r0, r1, r2
}

// MockOrderRepository_Paginate_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Paginate'
type MockOrderRepository_Paginate_Call struct {
	*mock.Call
}

// Paginate is a helper method to define mock.On call
//   - ctx context.Context
//   - page int
//   - perPage int
//   - scopes ...query.QueryScope
func (_e *MockOrderRepository_Expecter) Paginate(ctx interface{}, page interface{}, perPage interface{}, scopes ...interface{}) *MockOrderRepository_Paginate_Call {
	return &MockOrderRepository_Paginate_Call{Call: _e.mock.On("Paginate",
		append([]interface{}{ctx, page, perPage}, scopes...)...)}
}

func (_c *MockOrderRepository_Paginate_Call) Run(run func(ctx context.Context, page int, perPage int, scopes ...query.QueryScope)) *MockOrderRepository_Paginate_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 int
		if args[1] != nil {
			arg1 = args[1].(int)
		}
		var arg2 int
		if args[2] != nil {
			arg2 = args[2].(int)
		}
		var arg3 []query.QueryScope
		var variadicArgs []query.QueryScope
		if len(args) > 3 {
			variadicArgs = args[3].([]query.QueryScope)
		}
		arg3 = variadicArgs
		run(
			arg0,
			arg1,
			arg2,
			arg3...,
		)
	})
	return _c
}

func (_c *MockOrderRepository_Paginate_Call) Return(orders []*model.Order, n int, err error) *MockOrderRepository_Paginate_Call {
	_c.Call.Return(orders, n, err)
	return _c
}

func (_c *MockOrderRepository_Paginate_Call) RunAndReturn(run func(ctx context.Context, page int, perPage int, scopes ...query.QueryScope) ([]*model.Order, int, error)) *MockOrderRepository_Paginate_Call {
	_c.Call.Return(run)
	return _c
}

// RefundOrder provides a mock function for the type MockOrderRepository
func (_mock *MockOrderRepository) RefundOrder(ctx context.Context, orderID string, amount float64, reason string) error {
	ret := _mock.Called(ctx, orderID, amount, reason)

	if len(ret) == 0 {
		panic("no return value specified for RefundOrder")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string, float64, string) error); ok {
		r0 = returnFunc(ctx, orderID, amount, reason)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockOrderRepository_RefundOrder_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RefundOrder'
type MockOrderRepository_RefundOrder_Call struct {
	*mock.Call
}

// RefundOrder is a helper method to define mock.On call
//   - ctx context.Context
//   - orderID string
//   - amount float64
//   - reason string
func (_e *MockOrderRepository_Expecter) RefundOrder(ctx interface{}, orderID interface{}, amount interface{}, reason interface{}) *MockOrderRepository_RefundOrder_Call {
	return &MockOrderRepository_RefundOrder_Call{Call: _e.mock.On("RefundOrder", ctx, orderID, amount, reason)}
}

func (_c *MockOrderRepository_RefundOrder_Call) Run(run func(ctx context.Context, orderID string, amount float64, reason string)) *MockOrderRepository_RefundOrder_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		var arg2 float64
		if args[2] != nil {
			arg2 = args[2].(float64)
		}
		var arg3 string
		if args[3] != nil {
			arg3 = args[3].(string)
		}
		run(
			arg0,
			arg1,
			arg2,
			arg3,
		)
	})
	return _c
}

func (_c *MockOrderRepository_RefundOrder_Call) Return(err error) *MockOrderRepository_RefundOrder_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockOrderRepository_RefundOrder_Call) RunAndReturn(run func(ctx context.Context, orderID string, amount float64, reason string) error) *MockOrderRepository_RefundOrder_Call {
	_c.Call.Return(run)
	return _c
}

// RemoveItem provides a mock function for the type MockOrderRepository
func (_mock *MockOrderRepository) RemoveItem(ctx context.Context, itemID int64) error {
	ret := _mock.Called(ctx, itemID)

	if len(ret) == 0 {
		panic("no return value specified for RemoveItem")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, int64) error); ok {
		r0 = returnFunc(ctx, itemID)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockOrderRepository_RemoveItem_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RemoveItem'
type MockOrderRepository_RemoveItem_Call struct {
	*mock.Call
}

// RemoveItem is a helper method to define mock.On call
//   - ctx context.Context
//   - itemID int64
func (_e *MockOrderRepository_Expecter) RemoveItem(ctx interface{}, itemID interface{}) *MockOrderRepository_RemoveItem_Call {
	return &MockOrderRepository_RemoveItem_Call{Call: _e.mock.On("RemoveItem", ctx, itemID)}
}

func (_c *MockOrderRepository_RemoveItem_Call) Run(run func(ctx context.Context, itemID int64)) *MockOrderRepository_RemoveItem_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 int64
		if args[1] != nil {
			arg1 = args[1].(int64)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockOrderRepository_RemoveItem_Call) Return(err error) *MockOrderRepository_RemoveItem_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockOrderRepository_RemoveItem_Call) RunAndReturn(run func(ctx context.Context, itemID int64) error) *MockOrderRepository_RemoveItem_Call {
	_c.Call.Return(run)
	return _c
}

// Update provides a mock function for the type MockOrderRepository
func (_mock *MockOrderRepository) Update(ctx context.Context, order *model.Order) (*model.Order, error) {
	ret := _mock.Called(ctx, order)

	if len(ret) == 0 {
		panic("no return value specified for Update")
	}

	var r0 *model.Order
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *model.Order) (*model.Order, error)); ok {
		return returnFunc(ctx, order)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, *model.Order) *model.Order); ok {
		r0 = returnFunc(ctx, order)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*model.Order)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, *model.Order) error); ok {
		r1 = returnFunc(ctx, order)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockOrderRepository_Update_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Update'
type MockOrderRepository_Update_Call struct {
	*mock.Call
}

// Update is a helper method to define mock.On call
//   - ctx context.Context
//   - order *model.Order
func (_e *MockOrderRepository_Expecter) Update(ctx interface{}, order interface{}) *MockOrderRepository_Update_Call {
	return &MockOrderRepository_Update_Call{Call: _e.mock.On("Update", ctx, order)}
}

func (_c *MockOrderRepository_Update_Call) Run(run func(ctx context.Context, order *model.Order)) *MockOrderRepository_Update_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *model.Order
		if args[1] != nil {
			arg1 = args[1].(*model.Order)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockOrderRepository_Update_Call) Return(order1 *model.Order, err error) *MockOrderRepository_Update_Call {
	_c.Call.Return(order1, err)
	return _c
}

func (_c *MockOrderRepository_Update_Call) RunAndReturn(run func(ctx context.Context, order *model.Order) (*model.Order, error)) *MockOrderRepository_Update_Call {
	_c.Call.Return(run)
	return _c
}

// UpdateItem provides a mock function for the type MockOrderRepository
func (_mock *MockOrderRepository) UpdateItem(ctx context.Context, item *model.OrderItem) (*model.OrderItem, error) {
	ret := _mock.Called(ctx, item)

	if len(ret) == 0 {
		panic("no return value specified for UpdateItem")
	}

	var r0 *model.OrderItem
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *model.OrderItem) (*model.OrderItem, error)); ok {
		return returnFunc(ctx, item)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, *model.OrderItem) *model.OrderItem); ok {
		r0 = returnFunc(ctx, item)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*model.OrderItem)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, *model.OrderItem) error); ok {
		r1 = returnFunc(ctx, item)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockOrderRepository_UpdateItem_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdateItem'
type MockOrderRepository_UpdateItem_Call struct {
	*mock.Call
}

// UpdateItem is a helper method to define mock.On call
//   - ctx context.Context
//   - item *model.OrderItem
func (_e *MockOrderRepository_Expecter) UpdateItem(ctx interface{}, item interface{}) *MockOrderRepository_UpdateItem_Call {
	return &MockOrderRepository_UpdateItem_Call{Call: _e.mock.On("UpdateItem", ctx, item)}
}

func (_c *MockOrderRepository_UpdateItem_Call) Run(run func(ctx context.Context, item *model.OrderItem)) *MockOrderRepository_UpdateItem_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *model.OrderItem
		if args[1] != nil {
			arg1 = args[1].(*model.OrderItem)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockOrderRepository_UpdateItem_Call) Return(orderItem *model.OrderItem, err error) *MockOrderRepository_UpdateItem_Call {
	_c.Call.Return(orderItem, err)
	return _c
}

func (_c *MockOrderRepository_UpdateItem_Call) RunAndReturn(run func(ctx context.Context, item *model.OrderItem) (*model.OrderItem, error)) *MockOrderRepository_UpdateItem_Call {
	_c.Call.Return(run)
	return _c
}

// UpdatePaymentStatus provides a mock function for the type MockOrderRepository
func (_mock *MockOrderRepository) UpdatePaymentStatus(ctx context.Context, orderID string, paymentStatus string, transactionID string) error {
	ret := _mock.Called(ctx, orderID, paymentStatus, transactionID)

	if len(ret) == 0 {
		panic("no return value specified for UpdatePaymentStatus")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string, string, string) error); ok {
		r0 = returnFunc(ctx, orderID, paymentStatus, transactionID)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockOrderRepository_UpdatePaymentStatus_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdatePaymentStatus'
type MockOrderRepository_UpdatePaymentStatus_Call struct {
	*mock.Call
}

// UpdatePaymentStatus is a helper method to define mock.On call
//   - ctx context.Context
//   - orderID string
//   - paymentStatus string
//   - transactionID string
func (_e *MockOrderRepository_Expecter) UpdatePaymentStatus(ctx interface{}, orderID interface{}, paymentStatus interface{}, transactionID interface{}) *MockOrderRepository_UpdatePaymentStatus_Call {
	return &MockOrderRepository_UpdatePaymentStatus_Call{Call: _e.mock.On("UpdatePaymentStatus", ctx, orderID, paymentStatus, transactionID)}
}

func (_c *MockOrderRepository_UpdatePaymentStatus_Call) Run(run func(ctx context.Context, orderID string, paymentStatus string, transactionID string)) *MockOrderRepository_UpdatePaymentStatus_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		var arg2 string
		if args[2] != nil {
			arg2 = args[2].(string)
		}
		var arg3 string
		if args[3] != nil {
			arg3 = args[3].(string)
		}
		run(
			arg0,
			arg1,
			arg2,
			arg3,
		)
	})
	return _c
}

func (_c *MockOrderRepository_UpdatePaymentStatus_Call) Return(err error) *MockOrderRepository_UpdatePaymentStatus_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockOrderRepository_UpdatePaymentStatus_Call) RunAndReturn(run func(ctx context.Context, orderID string, paymentStatus string, transactionID string) error) *MockOrderRepository_UpdatePaymentStatus_Call {
	_c.Call.Return(run)
	return _c
}

// UpdateStatus provides a mock function for the type MockOrderRepository
func (_mock *MockOrderRepository) UpdateStatus(ctx context.Context, orderID string, newStatus string) error {
	ret := _mock.Called(ctx, orderID, newStatus)

	if len(ret) == 0 {
		panic("no return value specified for UpdateStatus")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string, string) error); ok {
		r0 = returnFunc(ctx, orderID, newStatus)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockOrderRepository_UpdateStatus_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdateStatus'
type MockOrderRepository_UpdateStatus_Call struct {
	*mock.Call
}

// UpdateStatus is a helper method to define mock.On call
//   - ctx context.Context
//   - orderID string
//   - newStatus string
func (_e *MockOrderRepository_Expecter) UpdateStatus(ctx interface{}, orderID interface{}, newStatus interface{}) *MockOrderRepository_UpdateStatus_Call {
	return &MockOrderRepository_UpdateStatus_Call{Call: _e.mock.On("UpdateStatus", ctx, orderID, newStatus)}
}

func (_c *MockOrderRepository_UpdateStatus_Call) Run(run func(ctx context.Context, orderID string, newStatus string)) *MockOrderRepository_UpdateStatus_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		var arg2 string
		if args[2] != nil {
			arg2 = args[2].(string)
		}
		run(
			arg0,
			arg1,
			arg2,
		)
	})
	return _c
}

func (_c *MockOrderRepository_UpdateStatus_Call) Return(err error) *MockOrderRepository_UpdateStatus_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockOrderRepository_UpdateStatus_Call) RunAndReturn(run func(ctx context.Context, orderID string, newStatus string) error) *MockOrderRepository_UpdateStatus_Call {
	_c.Call.Return(run)
	return _c
}
